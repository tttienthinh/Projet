import graphviz
from math import log2

# in the following, we refer to the complexity found here for the use of basic functions : https://www.python.org
class Graph:
    def __init__(self, nodes=[]):
        self.nodes = nodes
        self.graph = dict([(n, []) for n in nodes])
        self.nb_nodes = len(nodes)
        self.nb_edges = 0
        self.tree = None # a dict that contain for each node n a tuple (father f, height of n, power between n and f).
        # We put None if that's not a Tree
        self.power_2puiss = None # if the graph is a tree, this attribute contains a dict, for each node we have :
        # n : [2**i predecessor] for i=0 to int(log_2(height(n)))

    def __str__(self):  # complexity : O(nb_edges)
        """Prints the graph as a list of neighbors for each node (one per line)"""
        if not self.graph:
            output = "The graph is empty"
        else:
            output = f"The graph has {self.nb_nodes} nodes and {self.nb_edges} edges.\n"
            for source, destination in self.graph.items():
                output += f"{source}-->{destination}\n"
        return output

    def add_edge(self, node1, node2, power_min, dist=1):  # complexity : O(1)
        """
        Adds an edge to the graph. Graphs are not oriented, hence an edge is added to the adjacency list of both end nodes. 

        Parameters: 
        -----------
        node1: NodeType
            First end (node) of the edge
        node2: NodeType
            Second end (node) of the edge
        power_min: numeric (int or float)
            Minimum power on this edge
        dist: numeric (int or float), optional
            Distance between node1 and node2 on the edge. Default is 1.
        """
        self.nb_edges += 1
        self.graph[node1].append((node2, power_min, dist))
        self.graph[node2].append((node1, power_min, dist))

    def get_path_with_power(self, src, dest, power): # complexity : O(nb_nodes log(nb_nodes) + nb_edges)
        """
        Compute if a path exists between two nodes for a determinate maximal power, return None if does not exits
        it return a minimal distance path if it exists

        Parameters:
        -----------
        src: Any
            the departure node
        dest: Any
            the arrival node
        power: numeric (int or float)
            Maximum power for the route between the two nodes
        """
        power_dict = {node: None for node in self.nodes}
        power_dict[src] = 0
        path = {node: [] for node in self.nodes}
        path[src] = [src]
        dist_dict = {node: None for node in self.nodes}
        dist_dict[src] = 0
        pile = [(0, src)]
        while pile:  # Djikstras on dist
            """
            In this part we use the djikstra algorithm, and exclude the edges with a too big power
            """
            node_dist, node = min(pile)
            pile.remove((node_dist, node))
            if node == dest:  # Test if reached dest
                return path[dest]
            for end_node in self.graph[node]:
                end_node, power_between, dist_between = end_node
                if power_between <= power:  # Test if has enough power
                    if power_dict[end_node] is None or dist_between + dist_dict[node] < dist_dict[
                        end_node]:  # Test if found a better dist
                        power_dict[end_node] = max(power_between, power_dict[node])
                        dist_dict[end_node] = dist_between + dist_dict[node]
                        path[end_node] = path[node] + [end_node]
                        pile.append((dist_dict[end_node], end_node))
        return None

    def connected_components(self):  # complexity : O(nb_edges + nb_nodes) we go through every edge once
        """Return all the connected components of a graph in a list of list (for example the function 
        executed on the graph generated by network.01 will return [[1,2,3], [4,5,6,7]])"""
        components_list = []
        node_visited = {node: False for node in self.nodes}

        def find_component(node):  # complexity : O(nb_node^2) in the worst case (if the graph is full)
            # O(1) in the best case (if the node is not connected to anny other node)
            """Return all the accessible node from the input node as a list"""
            for end_node in self.graph[node]:
                end_node = end_node[0]
                if not node_visited[end_node]:
                    node_visited[end_node] = True
                    # changing it rather than returning the component prevent from stack overflow
                    # Segmentation fault (core dumped) for big graph
                    components_list[-1].append(end_node)
                    find_component(end_node)

        for node in self.nodes: # we are repeating nb_nodes times O(nb_nodes)
            if not node_visited[node]:
                components_list.append([node])
                find_component(node) # we will visite every edge from a same connex component O(nb_edges)

        return components_list

    def connected_components_set(self):  # complexity : the same as connected_components()
        """
        The result should be a set of frozensets (one per component), 
        For instance, for network01.in: {frozenset({1, 2, 3}), frozenset({4, 5, 6, 7})}
        """
        return set(map(frozenset, self.connected_components()))

    def min_power(self, src, dest): # complexity : O(nb_nodes log(nb_nodes) + nb_edges)
        """
        Should return path, min_power. 
        
        The indication in the instruction recommend to use 
        self.get_path_with_power with a dichotomy research thus doing it nlog(n) times ending with O(nlog(n)(nb_edges log(nb_edges)))

        We think that modifying Djikstra with the condition 
            max(power_between, power_dict[node]) < power_dict[node]
            rather than dist_between + dist_dict[node] < dist_dict[end_node]
        can end up with the same result 

        And it will be better in complexity because executing Djikstra ending with O(nb_edges log(nb_edges))
        """
        power_dict = {node: None for node in self.nodes}
        power_dict[src] = 0
        path = {node: [] for node in self.nodes}
        path[src] = [src]
        pile = [(0, src)]
        while pile != []:  # Djikstras on max power
            """in this part we use the principle of Djikstra algorithm
            """
            node_power, node = min(pile)
            pile.remove((node_power, node))
            if node == dest:  # Test if reached dest
                return path[dest], node_power
            for end_node in self.graph[node]:
                end_node, power_between, _ = end_node
                if power_dict[end_node] is None or max(power_between, power_dict[node]) < power_dict[
                    end_node]:  # Test if found a better power
                    power_dict[end_node] = max(power_between, power_dict[node])
                    path[end_node] = path[node] + [end_node]
                    pile.append((power_dict[end_node], end_node))

        return None, None

    def to_graphviz(self, comment="Graphe", view=True, src=None, dest=None):  
        # we do not calculate the complexity because we did'nt find the
        # complexity of graphviz functions
        """
        Args:
            comment: title of the generated file
            view: True if we want to display the result or not
        Returns: None
        """
        path = []
        if src is not None and dest is not None:
            path, _ = self.min_power(src, dest)
            if path is None:
                path = []
        path_couple = [{path[i], path[i+1]} for i in range(len(path)-1)]
        
        dot = graphviz.Graph(comment=comment)
        for node in self.nodes:
            if node == src:
                dot.node(f"{node}", str(node), color="forestgreen")
            elif node == dest:
                dot.node(f"{node}", str(node), color="firebrick")
            elif node in path:
                dot.node(f"{node}", str(node), color="dodgerblue")
            else:
                dot.node(f"{node}", str(node))
        for source, destinations in self.graph.items():
            for destination, power, dist in destinations:
                if source < destination:
                    # Le premier nombre est la puissance le deuxième est la distance
                    if {source, destination} in path_couple:
                        dot.edge(str(source), str(destination), label=f'{power}, {dist}', color="dodgerblue")
                    else:
                        dot.edge(str(source), str(destination), label=f'{power}, {dist}')
        dot.render(filename=f'graphviz/{comment}.gv', cleanup=True, view=view)

    def kruskal(self):
        """
        The complexity is O(nb_edges*log(nb_edges) + nb_nodes)
        """
        # Creating a list of vertices_list
        A = Graph(self.nodes)
        vertices_list = []  # this is a list of all the vertices
        already_added = {node: [] for node in self.nodes}
        for node1 in self.nodes:
            for node2, power, dist in self.graph[node1]:
                if (node2, power, dist) not in already_added[node1]:  # making sure each vertices is only appears once
                    vertices_list.append((power, dist, node1, node2))
                    already_added[node1].append((node2, power, dist))
                    already_added[node2].append((node1, power, dist))
        vertices_list.sort()  # we sort them O(nb_edges * log(n_edges))

        # Union Find with compression
        root = {node: node for node in self.nodes}
        def find(node):  # In the very worst case O(nb_nodes)
            if node != root[node]:
                root[node] = find(root[node]) # making a compression, to reduce complexity
            return root[node]

        # Adding edges to tree A
        i = 0
        while A.nb_edges < self.nb_nodes-1 and i < len(vertices_list):  # creating the tree in the worst case repeating
            # nb_edges and in the best case nb_nodes-1
            power, dist, node1, node2 = vertices_list[i]
            i += 1
            dad1 = find(node1) 
            dad2 = find(node2)
            if dad1 != dad2:  # Otherwise, it is a cycle
                A.add_edge(node1, node2, power, dist)
                root[dad1] = dad2 # Union
        return A

    def oriented_tree(self): # complexity : O(nb_nodes * log(nb_nodes))
        """
        The complexity is O(nb_nodes) (for loop) + Complexity of the function tree
        This lead to a final complexity of : O(nb_nodes * log(height)) which is always better or equal to
        O(nb_nodes * log(nb_nodes))
        """
        # This function can only be applied to trees (You can execute kruskal before executing this one)

        # We will choose the root of our tree as the node with the greatest number of neighbour
        root = self.nodes[0]
        max_neighbour = len(self.graph[root])
        for node in self.nodes[1:]:
            if len(self.graph[root]) > max_neighbour:
                root = node
                max_neighbour = len(self.graph[node])

        # defining the unique tree from root
        self.tree = {node: (node, 0, 0) for node in self.nodes}
        self.power_2puiss = {node: [] for node in self.nodes}

        def tree(ancestor, node, level):
            """
            This function is making orientating our tree, to give it a root
            And also give the power_min to reach the ancestor at 2^i
            Complexity is in O(nb_nodes * log(height))
            Args:
                ancestor: a list of ancestors
                node: the actual node that we are studying
                level: his level (hauteur dans l'arbre)
            """
            for child, power_min, dist in self.graph[node]:
                if child != ancestor[-2]: # We only visit children
                    power = power_min
                    for i in range(int(log2(level))): # we repeat it log(nb_nodes) time
                        ancestor_dist = ancestor[-int(2**i)]
                        self.power_2puiss[child].append((ancestor_dist, power))
                        power = max(power, self.power_2puiss[ancestor_dist][i][1])
                    dist = int(2**int(log2(level)))
                    self.power_2puiss[child].append((ancestor[-dist], power))
                    # the father of the child and the level to reach root
                    self.tree[child] = (node, level, power_min)
                    tree(ancestor+[child], child, level + 1)
        tree([None, root], root, 1)


    def kruskal_min_power(self, src, dest): # complexity : O(nb_nodes)
        """
        The complexity in the worst case is O(nb_nodes)
        But if we have choosen the best root in self.oriented_tree() it can be O(log(nb_nodes)) in average
        """
        # This fonction can only be applied to trees (You can execute kruskal before executing this one)
        if self.tree is None:
            self.oriented_tree()

        # We will go from src and dest to root
        def goto_root(node1, node2):  # node1 = src, node2 = dest
            dad1, level1, power1 = self.tree[node1]
            dad2, level2, power2 = self.tree[node2]
            if level1 == level2: # same height
                if node1 == node2:
                    return [node1, node2], 0
                path, power3 = goto_root(dad1, dad2)
                return [node1] + path + [node2], max(power1, power2, power3)
            if level1 > level2: # different height
                path, power3 = goto_root(dad1, node2)
                return [node1] + path, max(power1, power3)
            if level1 < level2: # different height
                path, power3 = goto_root(node1, dad2)
                return path + [node2], max(power2, power3)

        return goto_root(src, dest)
    
    def kruskal_2puiss_min_power(self, src, dest): # complexity O(log(nb_nodes))
        """
        The complexity in the worst case is O(nb_nodes)
        But if we have choosen the best root in self.oriented_tree() it can be O(log(nb_nodes)) in average
        """
        # This fonction can only be applied to trees (You can execute kruskal before executing this one)
        if self.tree is None:
            self.oriented_tree()

        # We will go from src and dest to root
        def goto_root(node1, node2):  # node1 = src, node2 = dest
            dad1, level1, power1 = self.tree[node1]
            dad2, level2, power2 = self.tree[node2]
            if level1 > level2: # Just to sort them
                return goto_root(node2, node1)
            if level1 < level2: # diffenrent height
                i = int(log2(level2-level1)) # going to nearest ancestor
                ancestor_i, puissance_i = self.power_2puiss[node2][i]
                power3 = goto_root(node1, ancestor_i)
                return max(puissance_i, power3)
            if level1 == level2: # Same height
                if node1 == node2:
                    return 0
                if dad1 == dad2:
                    return max(power1, power2)
                for i in range(int(log2(level1)+1)): # going to lower common ancester
                    if self.power_2puiss[node1][i][0] == self.power_2puiss[node2][i][0]:
                        ancestor1_i, power1_i = self.power_2puiss[node1][i-1]
                        ancestor2_i, power2_i = self.power_2puiss[node2][i-1]
                        return max(power1_i, power2_i, goto_root(ancestor1_i, ancestor2_i))
                    dist = int(log2(level1))
                    ancestor1_i, power1_i = self.power_2puiss[node1][dist]
                    ancestor2_i, power2_i = self.power_2puiss[node2][dist]
                    return max(power1_i, power2_i, goto_root(ancestor1_i, ancestor2_i))
                
        return goto_root(src, dest)

    @staticmethod
    def from_gpd_to_graph(dataframe, nodes):
        dataframe = dataframe.reset_index()
        graph = Graph(list(nodes.index))
        for index, row in dataframe.iterrows():
            try:
                if type(row["maxspeed"]) == str:
                    graph.add_edge(row["u"], row["v"], int(row["maxspeed"]), row["length"])
                elif type(row["maxspeed"]) == list:
                    graph.add_edge(row["u"], row["v"], int(row["maxspeed"][0]), row["length"])
                else:
                    graph.add_edge(row["u"], row["v"], 50, row["length"])
            except:
                graph.add_edge(row["u"], row["v"], 50, row["length"])
        return graph

def graph_from_file(filename):  # complexity : O(number of line)
    """
    Reads a text file and returns the graph as an object of the Graph class.

    The file should have the following format: 
        The first line of the file is 'n m'
        The next m lines have 'node1 node2 power_min dist' or 'node1 node2 power_min' (if dist is missing, it will be set to 1 by default)
        The nodes (node1, node2) should be named 1..n
        All values are integers.

    Parameters: 
    -----------
    filename: str
        The name of the file

    Outputs: 
    -----------
    G: Graph
        An object of the class Graph with the graph from file_name.
    """
    with open(filename) as file:
        def readline_to_listint():
            """
            Read the next line of file, and return this line as a list of integer
            
            Outputs: 
            -----------
            listint: list
                A list of integer [node1, node2, power_min, (dist)].
            """
            listline = file.readline().split()
            listint = [float(x) if '.' in x else int(x) for x in listline]
            return listint

        n, m = readline_to_listint()
        nodes = [i for i in range(1, n + 1)]
        G = Graph(nodes)
        for _ in range(m):
            args = readline_to_listint()
            G.add_edge(*args)
            # Grace à l'étoilé, on prend en compte dist qui peut, ou non être présent
    return G


if __name__ == "__main__":
    g = graph_from_file("input/network.04.in")
    g.connected_components()
    g.graph
    g.get_path_with_power(1, 2, 10)
    g.to_graphviz()
